#if !(defined __LINUX_BITMAP_H)
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__)
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__)
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__)
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__)
/*
 * int-ll64 is used practically everywhere now,
 * so use it as a reasonable default.
 */
/*
 * asm-generic/int-ll64.h
 *
 * Integer declarations for architectures which use "long long"
 * for 64-bit types.
 */

#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__)
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__)
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__)
#elif 0
#endif
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__)
/*
 * There seems to be no way of detecting this automatically from user
 * space, so 64 bit architectures should override this in their
 * bitsperlong.h. In particular, an architecture that supports
 * both 32 and 64 bit user space must not rely on CONFIG_64BIT
 * to decide it, but rather check a compiler provided macro.
 */
#if 0
#endif
#endif
#endif
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__)
/*
 * __xx is ok: it doesn't pollute the POSIX namespace. Use these in the
 * header files exported to user space
 */

typedef __signed__ char __s8;
typedef unsigned char __u8;

typedef __signed__ short __s16;
typedef unsigned short __u16;

typedef __signed__ int __s32;
typedef unsigned int __u32;

#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__)
__extension__ typedef __signed__ long long __s64;
__extension__ typedef unsigned long long __u64;
#elif 0
typedef __signed__ long long __s64;
typedef unsigned long long __u64;
#endif
#endif
#endif
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__)
typedef unsigned short umode_t;

#endif
/*
 * These aren't exported outside the kernel to avoid name space clashes
 */

#endif
#endif
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__)
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__)
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__)
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && (defined __cplusplus)
#elif !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && !(defined __cplusplus)
#endif
#endif
/*
 * This allows for 1024 file descriptors: if NR_OPEN is ever grown
 * beyond that you'll have to change this too. But 1024 fd's seem to be
 * enough even for such "real" unices like OSF/1, so hopefully this is
 * one limit that doesn't have to be changed [again].
 *
 * Note that POSIX wants the FD_CLEAR(fd,fdsetp) defines to be in
 * <sys/time.h> (and thus <linux/time.h>) - but this is a more logical
 * place for them. Solved by having dummy defines in <sys/time.h>.
 */

/*
 * Those macros may have been defined in <gnu/types.h>. But we always
 * use the ones here. 
 */
typedef struct {
	unsigned long fds_bits [(1024/(8 * sizeof(unsigned long)))];
} __kernel_fd_set;

/* Type of a signal handler.  */
typedef void (*__kernel_sighandler_t)(int);

/* Type of a SYSV IPC key.  */
typedef int __kernel_key_t;
typedef int __kernel_mqd_t;

#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && (defined __i386__)
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && (defined __i386__)
/*
 * This file is generally used by user-level software, so you need to
 * be a little careful about namespace pollution etc.  Also, we cannot
 * assume GCC is being used.
 */

typedef unsigned long	__kernel_ino_t;
typedef unsigned short	__kernel_mode_t;
typedef unsigned short	__kernel_nlink_t;
typedef long		__kernel_off_t;
typedef int		__kernel_pid_t;
typedef unsigned short	__kernel_ipc_pid_t;
typedef unsigned short	__kernel_uid_t;
typedef unsigned short	__kernel_gid_t;
typedef unsigned int	__kernel_size_t;
typedef int		__kernel_ssize_t;
typedef int		__kernel_ptrdiff_t;
typedef long		__kernel_time_t;
typedef long		__kernel_suseconds_t;
typedef long		__kernel_clock_t;
typedef int		__kernel_timer_t;
typedef int		__kernel_clockid_t;
typedef int		__kernel_daddr_t;
typedef char *		__kernel_caddr_t;
typedef unsigned short	__kernel_uid16_t;
typedef unsigned short	__kernel_gid16_t;
typedef unsigned int	__kernel_uid32_t;
typedef unsigned int	__kernel_gid32_t;

typedef unsigned short	__kernel_old_uid_t;
typedef unsigned short	__kernel_old_gid_t;
typedef unsigned short	__kernel_old_dev_t;

#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && (defined __i386__)
typedef long long	__kernel_loff_t;
#endif
typedef struct {
	int	val[2];
} __kernel_fsid_t;


#endif
#elif !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && !(defined __i386__)
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && !(defined __i386__)
/*
 * This file is generally used by user-level software, so you need to
 * be a little careful about namespace pollution etc.  Also, we cannot
 * assume GCC is being used.
 */

typedef unsigned long	__kernel_ino_t;
typedef unsigned int	__kernel_mode_t;
typedef unsigned long	__kernel_nlink_t;
typedef long		__kernel_off_t;
typedef int		__kernel_pid_t;
typedef int		__kernel_ipc_pid_t;
typedef unsigned int	__kernel_uid_t;
typedef unsigned int	__kernel_gid_t;
typedef unsigned long	__kernel_size_t;
typedef long		__kernel_ssize_t;
typedef long		__kernel_ptrdiff_t;
typedef long		__kernel_time_t;
typedef long		__kernel_suseconds_t;
typedef long		__kernel_clock_t;
typedef int		__kernel_timer_t;
typedef int		__kernel_clockid_t;
typedef int		__kernel_daddr_t;
typedef char *		__kernel_caddr_t;
typedef unsigned short	__kernel_uid16_t;
typedef unsigned short	__kernel_gid16_t;

#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && !(defined __i386__)
typedef long long	__kernel_loff_t;
#endif
typedef struct {
	int	val[2];
} __kernel_fsid_t;

typedef unsigned short __kernel_old_uid_t;
typedef unsigned short __kernel_old_gid_t;
typedef __kernel_uid_t __kernel_uid32_t;
typedef __kernel_gid_t __kernel_gid32_t;

typedef unsigned long	__kernel_old_dev_t;


#endif
#endif
#endif
/*
 * Below are truly Linux-specific types that should never collide with
 * any application/library that wants linux/types.h.
 */

#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && (defined __CHECKER__)
#elif !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && !(defined __CHECKER__)
#endif
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && (defined __CHECK_ENDIAN__)
#elif !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && !(defined __CHECK_ENDIAN__)
#endif
typedef __u16 
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && (defined __CHECK_ENDIAN__)
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && (defined __CHECKER__)
__attribute__((bitwise))
#elif !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && !(defined __CHECKER__)
#endif
#elif !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && !(defined __CHECK_ENDIAN__)
#endif
 __le16;
typedef __u16 
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && (defined __CHECK_ENDIAN__)
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && (defined __CHECKER__)
__attribute__((bitwise))
#elif !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && !(defined __CHECKER__)
#endif
#elif !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && !(defined __CHECK_ENDIAN__)
#endif
 __be16;
typedef __u32 
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && (defined __CHECK_ENDIAN__)
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && (defined __CHECKER__)
__attribute__((bitwise))
#elif !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && !(defined __CHECKER__)
#endif
#elif !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && !(defined __CHECK_ENDIAN__)
#endif
 __le32;
typedef __u32 
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && (defined __CHECK_ENDIAN__)
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && (defined __CHECKER__)
__attribute__((bitwise))
#elif !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && !(defined __CHECKER__)
#endif
#elif !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && !(defined __CHECK_ENDIAN__)
#endif
 __be32;
typedef __u64 
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && (defined __CHECK_ENDIAN__)
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && (defined __CHECKER__)
__attribute__((bitwise))
#elif !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && !(defined __CHECKER__)
#endif
#elif !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && !(defined __CHECK_ENDIAN__)
#endif
 __le64;
typedef __u64 
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && (defined __CHECK_ENDIAN__)
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && (defined __CHECKER__)
__attribute__((bitwise))
#elif !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && !(defined __CHECKER__)
#endif
#elif !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && !(defined __CHECK_ENDIAN__)
#endif
 __be64;

typedef __u16 
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && (defined __CHECK_ENDIAN__)
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && (defined __CHECKER__)
__attribute__((bitwise))
#elif !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && !(defined __CHECKER__)
#endif
#elif !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && !(defined __CHECK_ENDIAN__)
#endif
 __sum16;
typedef __u32 
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && (defined __CHECK_ENDIAN__)
#if !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && (defined __CHECKER__)
__attribute__((bitwise))
#elif !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && !(defined __CHECKER__)
#endif
#elif !(defined __LINUX_BITMAP_H) && !(defined __ASSEMBLY__) && !(defined __CHECK_ENDIAN__)
#endif
 __wsum;

#endif
#endif
/*#ifdef CONFIG_PROFILE_ALL_BRANCHES
#define if(cond, ...) __trace_if( (cond , ## __VA_ARGS__) )
#define __trace_if(cond) \
        if (__builtin_constant_p((cond)) ? !!(cond) :                   \
        ({                                                              \
                int ______r;                                            \
                static struct ftrace_branch_data                        \
                        __attribute__((__aligned__(4)))                 \
                        __attribute__((section("_ftrace_branch")))      \
                        ______f = {                                     \
                                .func = __func__,                       \
                                .file = __FILE__,                       \
                                .line = __LINE__,                       \
                        };                                              \
                ______r = !!(cond);                                     \
                ______f.miss_hit[______r]++;                                    \
                ______r;                                                \
        }))
#endif*/

//__trace_if(BITS_PER_LONG)

if (BITS_PER_LONG)

//if (BITS_PER_LONG)

//if (small_const_nbits(nbits))

#endif
#endif
